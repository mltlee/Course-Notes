\section{Discrete Logarithm Cryptography}

\subsection{Discrete Logarithm Problem}
Let $G = \langle g \rangle$ be a cyclic multiplicative group generated by 
$g \in G$ of finite order $\ord(g) = |G| = n$. The {\bf discrete logarithm 
problem} $\DLP$ in $G$ with respect to the base $g \in G$ is to find the integer 
$\alpha \in [1, n]$ such that $h = g^\alpha$ for a given $h \in G$. We assume 
that elements of $G$ can be represented using $O(\log n)$ bits, and that the 
multiplication operation in $G$ runs in polynomial time of the input size 
$O(\log n)$. 

Note that we assume that $G$ is multiplicative only for convenience in notation. 
$\DLP$ can be defined for any finite cyclic group in general. In fact, it 
can generalized to non-cyclic groups, or even to non-abelian groups, but we will 
not cover these generalizations in this course. 

In cryptography, we are mostly interested in finite cyclic groups $G$ such that 
the elements of $G$ can be represented efficiently, the group operation can be 
performed efficiently, but $\DLP$ is computationally infeasible. We will study 
several (public key) cryptographic schemes that are built on such groups. We 
will also present several algorithms for solving $\DLP$, discuss their 
implementations, and analyze their complexities. 

The security of the RSA encryption scheme relies heavily on the fact that integer 
factorization is a hard computational problem. We will now give some cryptographic
applications whose security relies on the fact that $\DLP$ (in the underlying 
group) is a hard computational problem. 

\subsection{Diffie-Hellman Key Exchange}
As we discussed in the beginning of the course, public key encryption can be 
utilized so that two parties (such as a client and a bank) can exchange a 
cryptographic key over an insecure channel, and then use their shared secret 
key and symmetric key cryptography to secure and authenticate their communication. 
\href{https://en.wikipedia.org/wiki/Merkle%27s_Puzzles}{Merkle's puzzles} (1974) 
and \href{https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange}
{Diffie-Hellman key exchange} (1976) protocols are two of the earliest known 
schemes that allow communicating secret information over public and insecure 
channels. 

In this section, we cover the Diffie-Hellman (DH) key exchange protocol. 
This is a protocol between two parties Alice and Bob, who we'll call $A$ and $B$. 
It is assumed that both parties have access to a generator $g$ of a finite 
(multiplicative) group $G$, and that they can efficiently perform group operations. 
In fact, it is even assumed that $G = \langle g \rangle$ is made publicly 
available to all parties, including adversaries. We now describe the steps of 
the protocol. 

\begin{enumerate}
    \item Make a finite cyclic (multiplicative) group $G$ and its generator $g$ 
          publicly available, with $|G| = n$. 
    \item $A$ chooses an integer $\alpha \in [1, n]$ uniformly at random, computes 
          $g_A = g^\alpha$, and sends $g_A$ to $B$. 
    \item $B$ chooses an integer $\beta \in [1, n]$ uniformly at random, computes 
          $g_B = g^\beta$, and sends $g_B$ to $A$. 
    \item After receiving $g_B = g^\beta$ from $B$, $A$ computes $K_{BA} = g_B^\alpha$. 
    \item After receiving $g_A = g^\alpha$ from $A$, $B$ computes $K_{AB} = g_A^\beta$. 
    \item Note that $K_{BA} = g^{\beta\alpha} = g^{\alpha\beta} = K_{AB}$, so $A$ and 
          $B$ can simultaneously derive a shared key $K$ from their parts $K_{BA}$
          and $K_{AB}$, respectively. One way would be to use a publicly defined
          \href{https://en.wikipedia.org/wiki/Key_derivation_function}{key 
          derivation function} $H$ such that $K = H(K_{BA}) = H(K_{AB})$. 
\end{enumerate}

Notice the abelian property of $G$ is important here because otherwise, we would 
not be guaranteed that $g^{\beta\alpha} = g^{\alpha\beta}$. 
We depict the above steps in the following figure. 

\begin{center}
    \begin{tikzcd}
        & {G=\langle g\rangle,~|G| = n} \arrow[ld, "(1)"] \arrow[rd, "(1)"'] & \\
        A                                               & & B \\[-2.5ex]
        {\alpha \in [1, n]} \arrow[r, "g_A = g^\alpha"] & (2), (3) & {\beta \in [1, n]} \arrow[l, "g_B = g^\beta"'] \\[-5ex]
        K_{BA} \gets g_B^\alpha                         & (4), (5) & K_{AB} \gets g_A^\beta \\[-5ex]
        K \gets H(K_{BA})                               & (6) & K \gets H(K_{AB})                             
    \end{tikzcd}
\end{center}

\subsection{The Security of Diffie-Hellman Key Exchange}

{\bf Active adversaries.} The basic DH scheme as presented in the previous 
section is insecure against active adversaries who may transmit, alter, or delete 
information over the communication channel. For example, consider an active 
adversary ${\rm Adv}$, who may impersonate Bob to Alice and Alice to Bob by 
actively interacting in the protocol. At the end of this adversarial protocol, 
Alice computes $g^{\beta'\alpha}$ and believes she shares this element with Bob, 
while Bob computes $g^{\alpha'\beta}$ and believes he shares this element with 
Alice. The adversary can then compute both $g^{\beta'\alpha}$ and $g^{\alpha'\beta}$, 
in which case they can decrypt, modify, and reencrypt any message shared between 
Alice and Bob without being noticed. 

\begin{center}
    \begin{tikzcd}
        \fbox{Alice: $\alpha$} \arrow[rr, shift left=2, "g^\alpha"] 
        & & \fbox{Adv: \textcolor{red}{$\beta', \alpha'$}} 
        \arrow[ll, red, shift left=2, "g^{\beta'}"] 
        \arrow[rr, red, shift left=2, "g^{\alpha'}"] 
        & & \fbox{Bob: $\beta$} \arrow[ll, shift left=2, "g^\beta"] \\
        {K_{{\rm Adv}, A} = g^{\beta'\alpha}} \arrow[rr, red, leftrightarrow] 
        & & {K_{A,{\rm Adv}} = g^{\alpha\beta'}}                                                        
        & & \\[-5ex]
        & & {K_{B,{\rm Adv}} = g^{\beta\alpha'}} \arrow[rr, red, leftrightarrow]                                                    
        & & {K_{{\rm Adv}, B} = g^{\alpha'\beta}} 
    \end{tikzcd}
\end{center}

This attack is known as a man-in-the-middle attack, and can be prevented using 
cryptographic methods for authentication and data integrity. See 
\href{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{man-in-the-middle}
and \href{https://en.wikipedia.org/wiki/Station-to-Station_protocol}
{station-to-station DH protocol} for more details. 

{\bf Passive adversaries; the computational Diffie-Hellman problem.} A passive 
adversary's actions are limited to eavesdropping on messages exchanged between 
legitimate parties in the protocol. Therefore, a passive adversary may listen to 
the DH protocol between Alice and Bob, with the objective of learning some 
nontrivial information about their shared key. More formally, given 
$[G, g, n, g^\alpha, g^\beta]$, recover some nontrivial information about 
$g^{\alpha\beta}$. Note that some information is trivial, such as the fact that 
$g^{\alpha\beta} \in G$. On the other hand, recovering $g^{\alpha\beta}$ would 
fully allow the adversary to share exactly the same key as Alice and Bob, 
and hence would break the DH protocol. 

This motivates the famous {\bf computational Diffie-Hellman} problem $\CDH$: given 
$[G, g, n, g^\alpha, g^\beta]$, where $G = \langle g \rangle$, $|G| = n$, 
and $\alpha, \beta \in [1, n]$ chosen uniformly at random, compute $g^{\alpha\beta}$. 
We will say that the DH protocol is {\bf secure} if any adversary who captures a 
copy of the protocol transcript $[G, g, n, g^\alpha, g^\beta]$ cannot recover 
$g^\beta$. Then the two computational problems $\BreakDH$ (breaking the DH 
key exchange protocol) and $\CDH$ are equivalent in the sense that any algorithm 
that can solve one of the two problems can be converted to another algorithm 
(in polynomial time of the input size) that solves the other problem. We denote this 
by $\BreakDH \equiv \CDH$. 

More generally, let $P_1$ and $P_2$ be two computational problems. 
\begin{enumerate}[(1)]
    \item We write $P_1 \leq P_2$ if $P_1$ can be reduced to $P_2$. We say that 
          $P_1$ is not harder than $P_2$, or $P_2$ is not easier than $P_1$. 
    \item We write $P_1 \equiv P_2$ if $P_1 \leq P_2$ and $P_2 \leq P_1$. 
          We say that $P_1$ and $P_2$ are equivalently hard. 
\end{enumerate}

For example, we can easily deduce that $\BreakDH \equiv \CDH \leq \DLP$. 
As a result, it is of great importance to us to study algorithms that solve 
$\CDH$ or $\DLP$ to get a sense of the security of DH key exchange. 

\subsection{ElGamal Public Key Encryption Scheme}
The ElGamal public key encryption scheme consists of the following three algorithms. 

\begin{enumerate}
    \item {\bf Key generation.} This algorithm creates a public key and secret key 
          pair. The public key is the tuple 
          \[ \PubKey = [G, n, g, h], \] 
          where $G$ is a finite cyclic group of order $n$ generated by $g$, and 
          $h = g^x$ for some integer $x \in [1, n]$. The integer $x$ is chosen 
          uniformly at random, and is the secret key; that is, 
          \[ \SecKey = [x]. \] 
    \item {\bf Encryption algorithm.} For a given public key $\PubKey = 
          [G, n, g, h]$, the encryption algorithm takes a message $m \in G$ as 
          input and outputs the ciphertext $c = [c_1, c_2]$ as a pair of elements 
          on $G$, where $c_1 = g^r$ for some $r \in [1, n]$ chosen uniformly 
          at random, and $c_2 = m \cdot h^r$. 
    \item {\bf Decryption algorithm.} For a given public key $\PubKey = 
          [G, n, g, h]$ and the secret key $\SecKey = [x]$, the decryption 
          algorithm takes as input a ciphertext $c = [c_1, c_2]$ from the 
          ciphertext space $G \times G$, and outputs the message 
          \[ m = c_2 \cdot c_1^{-x} \in G. \] 
\end{enumerate}

\subsection{The Security of the ElGamal Encryption Scheme}
An adversary may capture the public key $[G, n, g, h = g^x]$ of a user $A$ 
and a ciphertext $[c_1, c_2] = [g^r, m \cdot h^r]$ generated using $A$'s public 
key. Note that the adversary does not know $r$ and the secret key $x$ of $A$. 
The adversary may try to attack the ElGamal encryption scheme by trying to 
decrypt the ciphertext $[c_1, c_2]$ and recovering the message $m \in G$. 
We denote this computational problem by $\BreakElGamal$. An interesting 
result tells us that $\BreakElGamal$ and $\CDH$ are equivalently hard. 
We give a brief sketch of the proof. 

To see that $\BreakElGamal \leq \CDH$, suppose we are given an instance 
of $\BreakElGamal$, say 
\[ I = \{[G, n, g, h = g^x], [c_1 = g^r, c_2 = m \cdot h^r]\}. \] 
Moreover, assume that we have access to an oracle ${\cal O}_{\CDH}$ that solves 
$\CDH$ instances. Given our instance $I$ of $\BreakElGamal$, we first create 
a $\CDH$ instance $J = [G, n, g, c_1 = g^r, h = g^x]$, and query the 
oracle ${\cal O}_{\CDH}$ with $J$. This returns $g^{rx}$, which we can use 
to recover the message $m = c_2/g^{rx}$. 

For the direction $\CDH \leq \BreakElGamal$, suppose that we are given an 
instance of $\CDH$, say $I = [G, n, g, g^\alpha, g^\beta]$. Assume also that 
we have access to an oracle ${\cal O}_{\BreakElGamal}$ that solves 
$\BreakElGamal$ instances. Given our instance $I$ of $\CDH$, we create an 
$\BreakElGamal$ instance 
\[ J = \{[G, n, g, h = g^\alpha], [c_1 = g^\beta, c_2 = 1]\}, \] 
and query ${\cal O}_{\BreakElGamal}$ using $J$. This returns $c_2c_1^{-\alpha} 
= g^{-\alpha\beta}$, so we can recover $g^{\alpha\beta} = (c_2c_1^{-\alpha})^{-1}$. 