\section{Discrete Logarithm Cryptography}

\subsection{Discrete Logarithm Problem}
Let $\G = \langle g \rangle$ be a cyclic multiplicative group generated by 
$g \in \G$ of finite order $\ord(g) = |\G| = n$. The {\bf discrete logarithm 
problem} $\DLP$ in $\G$ with respect to the base $g \in \G$ is to find the integer 
$\alpha \in [1, n]$ such that $h = g^\alpha$ for a given $h \in \G$. We assume 
that elements of $\G$ can be represented using $O(\log n)$ bits, and that the 
multiplication operation in $\G$ runs in polynomial time of the input size 
$O(\log n)$. 

Note that we assume that $\G$ is multiplicative only for convenience in notation. 
$\DLP$ can be defined for any finite cyclic group in general. In fact, it 
can generalized to non-cyclic groups, or even to non-abelian groups, but we will 
not cover these generalizations in this course. 

In cryptography, we are mostly interested in finite cyclic groups $\G$ such that 
the elements of $\G$ can be represented efficiently, the group operation can be 
performed efficiently, but $\DLP$ is computationally infeasible. We will study 
several (public key) cryptographic schemes that are built on such groups. We 
will also present several algorithms for solving $\DLP$, discuss their 
implementations, and analyze their complexities. 

\subsection{Cryptographic Applications of the Discrete Logarithm Problem}
The security of the RSA encryption scheme relies heavily on the fact that integer 
factorization is a hard computational problem. We will now give some cryptographic
applications whose security relies on the fact that $\DLP$ (in the underlying 
group) is a hard computational problem. 

\subsubsection{Diffie-Hellman Key Exchange}
As we discussed in the beginning of the course, public key encryption can be 
utilized so that two parties (such as a client and a bank) can exchange a 
cryptographic key over an insecure channel, and then use their shared secret 
key and symmetric key cryptography to secure and authenticate their communication. 
\href{https://en.wikipedia.org/wiki/Merkle%27s_Puzzles}{Merkle's puzzles} (1974) 
and \href{https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange}
{Diffie-Hellman key exchange} (1976) protocols are two of the earliest known 
schemes that allow communicating secret information over public and insecure 
channels. 

In this section, we cover the Diffie-Hellman (DH) key exchange protocol. 
This is a protocol between two parties Alice and Bob, who we'll call $A$ and $B$. 
It is assumed that both parties have access to a generator $g$ of a finite 
(multiplicative) group $\G$, and that they can efficiently perform group operations. 
In fact, it is even assumed that $\G = \langle g \rangle$ is made publicly 
available to all parties, including adversaries. We now describe the steps of 
the protocol. 

\begin{enumerate}
    \item Make a finite cyclic (multiplicative) group $\G$ and its generator $g$ 
          publicly available, with $|\G| = n$. 
    \item $A$ chooses an integer $\alpha \in [1, n]$ uniformly at random, computes 
          $g_A = g^\alpha$, and sends $g_A$ to $B$. 
    \item $B$ chooses an integer $\beta \in [1, n]$ uniformly at random, computes 
          $g_B = g^\beta$, and sends $g_B$ to $A$. 
    \item After receiving $g_B = g^\beta$ from $B$, $A$ computes $K_{BA} = g_B^\alpha$. 
    \item After receiving $g_A = g^\alpha$ from $A$, $B$ computes $K_{AB} = g_A^\beta$. 
    \item Note that $K_{BA} = g^{\beta\alpha} = g^{\alpha\beta} = K_{AB}$, so $A$ and 
          $B$ can simultaneously derive a shared key $K$ from their parts $K_{BA}$
          and $K_{AB}$, respectively. One way would be to use a publicly defined
          \href{https://en.wikipedia.org/wiki/Key_derivation_function}{key 
          derivation function} $H$ such that $K = H(K_{BA}) = H(K_{AB})$. 
\end{enumerate}

Notice the abelian property of $\G$ is important here because otherwise, we would 
not be guaranteed that $g^{\beta\alpha} = g^{\alpha\beta}$. 
We depict the above steps in the following figure. 

\begin{center}
    \begin{tikzcd}
        & {\G=\langle g\rangle,~|\G| = n} \arrow[ld, "(1)"] \arrow[rd, "(1)"'] & \\
        A                                               & & B \\[-2.5ex]
        {\alpha \in [1, n]} \arrow[r, "g_A = g^\alpha"] & (2), (3) & {\beta \in [1, n]} \arrow[l, "g_B = g^\beta"'] \\[-5ex]
        K_{BA} \gets g_B^\alpha                         & (4), (5) & K_{AB} \gets g_A^\beta \\[-5ex]
        K \gets H(K_{BA})                               & (6) & K \gets H(K_{AB})                             
    \end{tikzcd}
\end{center}

\subsubsection{The Security of Diffie-Hellman Key Exchange}

{\bf Active adversaries.} The basic DH scheme as presented in the previous 
section is insecure against active adversaries who may transmit, alter, or delete 
information over the communication channel. For example, consider an active 
adversary ${\rm Adv}$, who may impersonate Bob to Alice and Alice to Bob by 
actively interacting in the protocol. At the end of this adversarial protocol, 
Alice computes $g^{\beta'\alpha}$ and believes she shares this element with Bob, 
while Bob computes $g^{\alpha'\beta}$ and believes he shares this element with 
Alice. The adversary can then compute both $g^{\beta'\alpha}$ and $g^{\alpha'\beta}$, 
in which case they can decrypt, modify, and reencrypt any message shared between 
Alice and Bob without being noticed. 

\begin{center}
    \begin{tikzcd}
        \fbox{Alice: $\alpha$} \arrow[rr, shift left=2, "g^\alpha"] 
        & & \fbox{Adv: \textcolor{red}{$\beta', \alpha'$}} 
        \arrow[ll, red, shift left=2, "g^{\beta'}"] 
        \arrow[rr, red, shift left=2, "g^{\alpha'}"] 
        & & \fbox{Bob: $\beta$} \arrow[ll, shift left=2, "g^\beta"] \\
        {K_{{\rm Adv}, A} = g^{\beta'\alpha}} \arrow[rr, red, leftrightarrow] 
        & & {K_{A,{\rm Adv}} = g^{\alpha\beta'}}                                                        
        & & \\[-5ex]
        & & {K_{B,{\rm Adv}} = g^{\beta\alpha'}} \arrow[rr, red, leftrightarrow]                                                    
        & & {K_{{\rm Adv}, B} = g^{\alpha'\beta}} 
    \end{tikzcd}
\end{center}

This attack is known as a man-in-the-middle attack, and can be prevented using 
cryptographic methods for authentication and data integrity. See 
\href{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{man-in-the-middle}
and \href{https://en.wikipedia.org/wiki/Station-to-Station_protocol}
{station-to-station DH protocol} for more details. 

{\bf Passive adversaries; the computational Diffie-Hellman problem.} A passive 
adversary's actions are limited to eavesdropping on messages exchanged between 
legitimate parties in the protocol. Therefore, a passive adversary may listen to 
the DH protocol between Alice and Bob, with the objective of learning some 
nontrivial information about their shared key. More formally, given 
$[\G, g, n, g^\alpha, g^\beta]$, recover some nontrivial information about 
$g^{\alpha\beta}$. Note that some information is trivial, such as the fact that 
$g^{\alpha\beta} \in \G$. On the other hand, recovering $g^{\alpha\beta}$ would 
fully allow the adversary to share exactly the same key as Alice and Bob, 
and hence would break the DH protocol. 

This motivates the famous {\bf computational Diffie-Hellman} problem $\CDH$: given 
$[\G, g, n, g^\alpha, g^\beta]$, where $\G = \langle g \rangle$, $|\G| = n$, 
and $\alpha, \beta \in [1, n]$ chosen uniformly at random, compute $g^{\alpha\beta}$. 
We will say that the DH protocol is {\bf secure} if any adversary who captures a 
copy of the protocol transcript $[\G, g, n, g^\alpha, g^\beta]$ cannot recover 
$g^\beta$. Then the two computational problems $\BreakDH$ (breaking the DH 
key exchange protocol) and $\CDH$ are equivalent in the sense that any algorithm 
that can solve one of the two problems can be converted to another algorithm 
(in polynomial time of the input size) that solves the other problem. We denote this 
by $\BreakDH \equiv \CDH$. 

More generally, let $P_1$ and $P_2$ be two computational problems. 
\begin{enumerate}[(1)]
    \item We write $P_1 \leq P_2$ if $P_1$ can be reduced to $P_2$. We say that 
          $P_1$ is not harder than $P_2$, or $P_2$ is not easier than $P_1$. 
    \item We write $P_1 \equiv P_2$ if $P_1 \leq P_2$ and $P_2 \leq P_1$. 
          We say that $P_1$ and $P_2$ are equivalently hard. 
\end{enumerate}

For example, we can easily deduce that $\BreakDH \equiv \CDH \leq \DLP$. 
As a result, it is of great importance to us to study algorithms that solve 
$\CDH$ or $\DLP$ to get a sense of the security of DH key exchange. 

\subsubsection{ElGamal Public Key Encryption Scheme}
The ElGamal public key encryption scheme consists of the following three algorithms. 

\begin{enumerate}
    \item {\bf Key generation.} This algorithm creates a public key and secret key 
          pair. The public key is the tuple 
          \[ \PubKey = [\G, n, g, h], \] 
          where $\G$ is a finite cyclic group of order $n$ generated by $g$, and 
          $h = g^x$ for some integer $x \in [1, n]$. The integer $x$ is chosen 
          uniformly at random, and is the secret key; that is, 
          \[ \SecKey = [x]. \] 
    \item {\bf Encryption algorithm.} For a given public key $\PubKey = 
          [\G, n, g, h]$, the encryption algorithm takes a message $m \in \G$ as 
          input and outputs the ciphertext $c = [c_1, c_2]$ as a pair of elements 
          on $\G$, where $c_1 = g^r$ for some $r \in [1, n]$ chosen uniformly 
          at random, and $c_2 = m \cdot h^r$. 
    \item {\bf Decryption algorithm.} For a given public key $\PubKey = 
          [\G, n, g, h]$ and the secret key $\SecKey = [x]$, the decryption 
          algorithm takes as input a ciphertext $c = [c_1, c_2]$ from the 
          ciphertext space $\G \times \G$, and outputs the message 
          \[ m = c_2 \cdot c_1^{-x} \in \G. \] 
\end{enumerate}

\subsubsection{The Security of the ElGamal Encryption Scheme}
An adversary may capture the public key $[\G, n, g, h = g^x]$ of a user $A$ 
and a ciphertext $[c_1, c_2] = [g^r, m \cdot h^r]$ generated using $A$'s public 
key. Note that the adversary does not know $r$ and the secret key $x$ of $A$. 
The adversary may try to attack the ElGamal encryption scheme by trying to 
decrypt the ciphertext $[c_1, c_2]$ and recovering the message $m \in \G$. 
We denote this computational problem by $\BreakElGamal$. An interesting 
result tells us that $\BreakElGamal$ and $\CDH$ are equivalently hard. 
We give a brief sketch of the proof. 

To see that $\BreakElGamal \leq \CDH$, suppose we are given an instance 
of $\BreakElGamal$, say 
\[ I = \{[\G, n, g, h = g^x], [c_1 = g^r, c_2 = m \cdot h^r]\}. \] 
Moreover, assume that we have access to an oracle ${\cal O}_{\CDH}$ that solves 
$\CDH$ instances. Given our instance $I$ of $\BreakElGamal$, we first create 
a $\CDH$ instance $J = [\G, n, g, c_1 = g^r, h = g^x]$, and query the 
oracle ${\cal O}_{\CDH}$ with $J$. This returns $g^{rx}$, which we can use 
to recover the message $m = c_2/g^{rx}$. 

For the direction $\CDH \leq \BreakElGamal$, suppose that we are given an 
instance of $\CDH$, say $I = [\G, n, g, g^\alpha, g^\beta]$. Assume also that 
we have access to an oracle ${\cal O}_{\BreakElGamal}$ that solves 
$\BreakElGamal$ instances. Given our instance $I$ of $\CDH$, we create an 
$\BreakElGamal$ instance 
\[ J = \{[\G, n, g, h = g^\alpha], [c_1 = g^\beta, c_2 = 1]\}, \] 
and query ${\cal O}_{\BreakElGamal}$ using $J$. This returns $c_2c_1^{-\alpha} 
= g^{-\alpha\beta}$, so we can recover $g^{\alpha\beta} = (c_2c_1^{-\alpha})^{-1}$. 

\subsection{Algorithms for the Discrete Logarithm Problem}
As we have seen in the previous sections, one way to break the security of the 
Diffie-Hellman key exchange protocol and the ElGamal encryption scheme is to solve 
the discrete logarithm problem. In this section, we describe some algorithms to 
solve $\DLP$, and study their efficiency. This will give us a better sense of the 
security of discrete logarithm based cryptographic schemes, and might suggest some 
important criterion for selecting the underlying groups and their parameters.

\subsubsection{Exhaustive Search and Shanks' Baby-Step-Giant-Step Algorithms}
A naive way to solve $\DLP$ in $\G$ would be to exhaustively search for $\alpha
\in [1, n]$ such that $g^\alpha = h$. This algorithm would require us to perform 
$O(n)$ group exponentiations and equality checks of group elements, which is 
exponential in the size of the input $O(\log_2 n)$.

Shanks' baby-step-giant-step algorithm offers a quadratic speedup over the 
exhaustive search algorithm; it requires $O(\sqrt{n})$ group exponentiations 
and equality checks of group elements, as well as storing $O(\sqrt{n})$ 
group elements in a table. It is based on the observation that for 
$m = \lfloor{\sqrt n}\rfloor$, one can write 
\[ g^\alpha = g^{i+jm} = h, \] 
for some integers $i, j \in [1, m]$, which is equivalent to saying that 
\[ g^i = hg_m^j \] 
where $g_m = g^{-m}$. In the algorithm, one computes and stores a list of 
values $g^i$ (baby steps of length $1$) for $i = 0, \dots, m$. Then, one 
computes $g_m^j$ for $j = 0, 1, \dots, m$ until $hg_m^j$ (giant steps of 
length $m$) matches one of the values $g^i$, where $g_m = g^{-m}$ as before. 
Once a match is found, the algorithm outputs $\alpha = i + jm$. This 
requires $O(\sqrt n)$ group exponentiations and table lookups, in addition 
to storing $O(\sqrt n)$ group elements. 

\subsubsection{Pollard's $\rho$-algorithm}
Suppose we are trying to compute the discrete logarithm of $h = g^\alpha$ 
with respect to a generator $g \in \G$. Let $x_i = g^{m_i} h^{n_i}$ for some 
$m_i, n_i \in \Z$. Suppose that we are lucky and find two distinct indices 
$i$ and $j$ such that $x_i = x_j$. That is, we have $g^{m_i} h^{n_i} 
= g^{m_j} h^{n_j}$. This would imply that $g^{m_i-m_j} = h^{n_j-n_i}$, and hence 
\[ m_i - m_j \equiv \alpha(n_j - n_i) \pmod n, \] 
where $n$ is the order of $\G$. Assuming that $(n_j - n_i)$ is coprime with $n$, 
we can recover $\alpha \in [1, n]$ by taking 
\[ \alpha \equiv (m_i - m_j)(n_j - n_i)^{-1} \pmod n. \] 
We can select the pairs $(m_i, n_i)$ for integers $i \geq 1$ independently at 
random from $[1, n] \times [1, n]$, and hope to find a collision (or repetition) 
among the values of $x_i = g^{m_i} h^{n_i}$. By the birthday paradox, we would expect 
to compute and store about $O(\sqrt n)$ instances of $x_i$ before finding a 
collision. This idea yields a $\DLP$ solver whose computational and storage 
complexities are similar to Shanks' baby-step-giant-step algorithm. Next, 
we will describe how to reduce the memory capacity of the algorithm from 
$O(\sqrt n)$ to $O(1)$. 

Start with $m_0 = n_0 = 1$ so that $x_0 = g^{m_0} h^{n_0} = 1$. Furthermore, 
suppose that $\G$ is partitioned into three subsets of almost equal size; that is, 
$\G = S_1 \cup S_2 \cup S_3$ with each $|S_i| \approx |\G|/3$. Define a function 
$F : \G \times \Z_n \times \Z_n \to \G \times \Z_n \times \Z_n$ by 
\begin{align*}
      (x_i, m_i, n_i) \mapsto \begin{cases}
            (hx_i, m_i, n_i+1) & \text{if } x_i \in S_1, \\ 
            (x_i^2, 2m_i, 2n_i) & \text{if } x_i \in S_2, \\ 
            (gx_i, m_i+1, n_i) & \text{if } x_i \in S_3. 
      \end{cases}
\end{align*}
Notice that $F$ induces another function $f : \G \to \G$ such that $x_0 = 1$ and 
$x_{i+1} = f(x_i)$. Assuming that $f$ leads to a random walk $x_0, x_1, x_2, \dots$ 
in $\G$, we expect (based on the birthday paradox) that there exist two indices 
$i$ and $j = i+\lambda$ such that $x_i = x_j = x_{i+\lambda}$ for some 
$j = O(\sqrt n)$. 
\begin{center}
      \begin{tikzpicture}[]
            \draw (0,0) to[out=90, in=180] (2,5) to[out=0, in=90] (3, 4) 
                  to[out=-90, in=0] (2, 3) to[out=180, in=-45] (0.25, 3.5);
            \draw[fill=black] (0,0) circle (0.05cm);
            \draw(-0.1,0) node[left]{$x_0$} (0, 0);
            \draw[fill=black] (0, 0.75) circle (0.05cm);
            \draw(-0.1,0.75) node[left]{$x_1$} (0, 0.75);
            \draw[fill=black] (0, 1.5) circle (0.05cm);
            \draw(-0.1,1.5) node[left]{$x_2$} (0, 1.5);
            \draw[fill=black] (0.06, 2.5) circle (0.05cm);
            \draw(-0.04,2.5) node[left]{\rotatebox[origin=c]{85}{$\cdots$}} (0.06, 2.5);
            \draw(0.15, 3.5) node[left]{$x_i = x_j = x_{i+\lambda}$} (0.25, 3.5);
            \draw[fill=black] (0.25, 3.5) circle (0.05cm);
            \draw[fill=black] (0.55, 4.2) circle (0.05cm);
            \draw[fill=black] (1, 4.7) circle (0.05cm);
            \draw[fill=black] (2, 5) circle (0.05cm);
            \draw(2,5.1) node[above]{$\cdots$} (2, 5);
            \draw[fill=black] (3, 4) circle (0.05cm);
            \draw[fill=black] (2.5, 3.15) circle (0.05cm);
            \draw(2.5,3.05) node[below]{\rotatebox[origin=c]{15}{$\cdots$}} (2.5, 3.15);
            \draw[fill=black] (1.75, 3) circle (0.05cm);
            \draw(1.75, 2.9) node[below]{$x_{j-2}$} (1.75, 3);
            \draw[fill=black] (0.9, 3.1) circle (0.05cm);
            \draw(0.9, 3) node[below]{$x_{j-1}$} (0.9, 3.1);
      \end{tikzpicture}
\end{center}
Then we would have 
\[ x_i = x_{i+\lambda} = x_{2i+\lambda} = x_{3i+\lambda} = \cdots, \]
meaning that $x_{i'} = x_{j'}$ for all $i', j' \in \Z$ with $j' - i' \equiv 0 \pmod 
\lambda$ and $i' > i$. In particular, we have $x_{i'} = x_{2i'}$ for all 
$i' \equiv 0 \pmod \lambda$ and $i' > i$. Now, since one of the integers $i'$ 
in $\{i, i+1, \dots, j-1\}$ must be divisible by $\lambda$, we can get to 
$x_{i'} = x_{2i'}$ by simply evaluating $f$ and checking the equality of 
group elements after at most $j = i+\lambda$ steps. Namely, we are comparing 
\begin{itemize}
      \item $x_1$ and $x_2$, where $x_1 = f(x_0)$ and $x_2 = f(x_1)$; 
      \item $x_3$ and $x_4$, where $x_3 = f(x_2)$ and $x_4 = f(x_3) = f(f(x_2))$;
      \item $\cdots$
      \item $x_{i'-1}$ and $x_{2i'-2}$, where $x_{i'-1} = f(x_{i'-2})$ and 
            $x_{2i'-2} = f(x_{2i'-3}) = f(f(x_{2i'-4}))$; 
      \item $x_{i'}$ and $x_{2i'}$, where $x_{i'} = f(x_{i'-1})$ and 
            $x_{2i'} = f(x_{2i'-1}) = f(f(x_{2i'-2}))$. 
\end{itemize}
We would expect to identify a collision of group elements within $O(\sqrt n)$ 
steps and $O(1)$ memory, which can be used to recover $\alpha \in [1, n]$ 
such that $g^\alpha = h$. 

\subsubsection{The Pohlig-Hellman Algorithm}
Let $\G$ be a finite group with generator $g \in \G$ and $\ord(g) = |\G| = n$. 
Given $h \in \G$, we want to find $\alpha \in [1, n]$ such that $g^\alpha = h$. 
Notice that $g^n = 1 = g^0$, so we may equivalently assume that $\alpha 
\in [0, n-1]$. 

Suppose that $n = \prod_{i=1}^k p_i^{e_i}$. The Pohlig-Hellman algorithm 
\cite{1055817} solves $\DLP$ by first solving $\DLP$ in the subgroups of $\G$ 
of order $p_i^{e_i}$, and then combines these solutions using the Chinese 
remainder theorem. We now give the details of the algorithm. 

Write $n = p_i^{e_i} r_i$, and define $\G_i$ to be the subgroup of $\G$ of order 
$p_i^{e_i}$. Moreover, set $g_i = g^{r_i}$, $h_i = h^{r_i}$, and 
$\alpha_i = \alpha \pmod{p_i^{e_i}}$. Observe that $g^\alpha = h$ implies 
$(g^\alpha)^{r_i} = h^{r_i}$, and hence 
\[ (g_i)^{\alpha_i} = (g_i)^\alpha = h_i, \] 
where the first equality is because $g_i$ is an element of order $p_i^{e_i}$. 
In the Pohlig-Hellman algorithm, one computes $g_i$ and $h_i$, and solves the 
discrete logarithm $\alpha_i$ of $h_i$ with respect to $g_i$ for each 
$i = 1, \dots, k$. By the Chinese remainder theorem, we can recover the unique 
solution $\alpha \in [0, n-1]$ such that $\alpha \equiv \alpha_i 
\pmod{p_i^{e_i}}$ for all $i = 1, \dots, k$. More precisely, we have 
\[ \alpha = \sum_{i=1}^k \alpha_i \theta_i \theta'_i, \] 
where $\theta_i = n/p_i^{e_i}$ and $\theta'_i = \theta_i^{-1} \pmod{p_i^{e_i}}$. 

\newpage 
Consequently, we can estimate the cost of the Pohlig-Hellman algorithm as 
\[ \sum_{i=1}^k (C(\DLP)_i + 2C(\EXP)_i) + C_k(\CRT) = 
O \left( \sum_{i=1}^k \sqrt{p_i^{e_i}} (\log_2 n)^2 \right) + 
O(k(\log_2 n)^3) + O(k(\log_2 n)^2), \] 
where $C(\DLP)_i$ is the bit complexity of solving $\DLP$ in $\G_i$, 
$C(\EXP)_i = O((\log_2 n)^3)$ is the bit complexity of performing exponentiation 
by $r_i$ in $\G_i$, and $C_k(\CRT) = O((\log_2 n)^2)$ is the bit complexity of 
applying the Chinese remainder theorem. If we use Pollard's $\rho$-algorithm 
to solve $\DLP$ in each $\G_i$, then we can estimate that 
\[ C(\DLP)_i = O\left( \sqrt{p_i^{e_i}} (\log_2 n)^2 \right). \] 
Notice that if $n$ is prime, then the Pohlig-Hellman approach offers no advantage 
over Pollard's $\rho$-algorithm since both their bit complexities become 
$O(\sqrt n (\log_2 n)^2)$. However, when $n$ is smooth and can be written as 
the product of small prime powers, then Pohlig-Hellman outperforms Pollard's 
$\rho$-algorithm.

{\bf Solving $\DLP$ in groups of order a prime power.} Now, we present 
an alternative method to Pollard's $\rho$-algorithm for solving $\DLP$ in the 
case that we are working with a cyclic group with order a prime power. 
Let $\G_{p,e}$ be a cyclic group of order $p^e$, where $p$ is a prime power and 
$e \geq 1$ is an integer. This method is more efficient than Pollard's 
$\rho$-algorithm when $e \geq 2$, and can be used to solve $\DLP$ in each $\G_i$ 
in the Pohlig-Hellman algorithm. 

Given a generator $\rho$ of $\G_{p,e}$ and $\gamma \in \G$, we want to find 
$\beta \in [0, p^e - 1]$ such that $\rho^\beta = \gamma$. First, we write 
$\beta = \sum_{i=0}^{e-1} d_i p^i$, and define 
\[ \gamma_j = \rho^{\sum_{i=j}^{e-1} d_j p^j} \] 
for each $j = 0, 1, \dots, e-1$. Note that $\gamma_0 = \gamma$ and 
\begin{equation} \gamma_{j+1} = \gamma_j \rho^{-d_j p^j} \end{equation}
for $j = 0, 1, \dots, e-2$. Since the order of $\rho$ is $p^e$, we have 
\[ \gamma_j^{p^{e-1-j}} = \left( \rho^{p^{e-1}} \right)^{d_j}. \] 
Hence, we can recover $d_j$ by solving the discrete logarithm of 
$\gamma_j^{p^{e-1-j}}$ in $\G_{p,1} = \langle \rho^{p^{e-1}} \rangle$. In order 
to recover $\beta = \sum_{i=0}^{e-1} d_i p^i$, we start with $\gamma_0 = \gamma$,
and compute $\bar\gamma_0 = \gamma_0^{p^{e-1}}$ and $\bar\rho = 
\rho^{p^{e-1}}$. We can then recover $d_0$ as the \\[4pt] discrete logarithm of 
$\bar\gamma_0$ in $\G_{p,1} = \langle \bar\rho \rangle$. For $j = 1, \dots, p-1$, 
we then compute $\gamma_j$ using the relation in $(6.1)$. We can then obtain 
$d_j$ as the discrete logarithm of $\bar\gamma_j = \gamma_j^{p^{e-1-j}}$ in 
$\G_{p,1} = \langle \bar\rho \rangle$. Once $d_0, d_1, \dots, d_{e-1}$ are 
all known, we can determine $\beta = \sum_{i=0}^{e-1} d_i p^i$. 

Note that if a table $T$ of elements is precomputed and stored with $T[j] 
= \rho^{-p^j}$ for $0 \leq j \leq p-1$, then we can discuss the complexity of 
the process as below. 
\begin{enumerate}
      \item We compute $\gamma_j$ for $j = 0, 1, \dots, e-1$ using $(6.1)$ 
            and the lookup table $T$ via 
            \[ \gamma_j = \gamma_{j-1} T[j-1]^D \] 
            for some $0 \leq D \leq p-1$. The estimated cost (number of group 
            operations) is $O(e\log_2 p)$. 
      \item We compute $\bar\gamma_j$ for $j = 0, 1, \dots, e-1$. This gives a 
            total of 
            \[ (e-1) + (e-2) + \cdots + 1 + \frac{(e-1)e}2 \] 
            group exponentiation operations in $\G_{p,e}$. The estimated cost is 
            $O(e^2\log_2 p)$. 
      \item To recover $d_j$ for $j = 0, 1, \dots, e-1$, we use Pollard's 
            $\rho$-algorithm to solve the discrete logarithm of $\bar\gamma_j$ 
            in $\G_{p,1} = \langle \bar\rho \rangle$. The estimated cost is 
            $O(e\sqrt p)$. 
\end{enumerate}
The total number of group operations required for solving $\DLP$ in $\G_{p,e}$ 
with this approach is estimated as $O(e\sqrt p)$, which is better than the 
$O(\sqrt{p^e})$ estimate for Pollard's $\rho$-algorithm when $e \geq 2$. 

\subsubsection{The Index Calculus Algorithm}
The $\DLP$ solvers we have covered so far are general purpose algorithms in the 
sense that they do not rely on any algebraic property of the underlying group 
other than the ability to efficiently perform group operations. The index calculus 
method is a special purpose algorithm and it exploits algebraic properties of the 
group. In this way, we obtain better $\DLP$ solvers for certain groups. However, 
the tradeoff is that there are groups that index calculus does not seem to apply.
We present the index calculus algorithm to solve $\DLP$ in $\Z_p^*$, where 
$p$ is prime. We describe it right away because it resembles the 
random squares factor finding algorithm. 

\begin{algo}[Index Calculus Algorithm]~

      {\bf Input:} A prime $p$, a generator $g$ of $\Z_p^*$, and $h \in \Z_p^*$. 
      
      {\bf Output:} An integer $\alpha \in [0, p-1]$ such that $g^\alpha = h$.

      \begin{enumerate}[1.]
            \item Set $\FB = \{p_1, p_2, \dots, p_{\pi(B)}\}$ as the factor basis 
                  consisting of all primes less than or equal to $B$. 
            \item Set an empty matrix $M$, which will eventually be a $T \times 
                  \pi(B)$ matrix. 
            \item Set $i \gets 1$ and $T = \pi(B) + 10$. 
            \item Assume that $d_j \in [0, p-1]$ is the discrete logarithm 
                  of $p_j \in \Z_p^*$ with respect to $g$; that is, $g^{d_j} = p_j$.
            \item {\bf Relation generation stage.} 
                  \begin{itemize}
                        \item Select $1 \leq x_i \leq p-2$ uniformly at random. 
                        \item {\bf if $g^{x_i} \pmod p$ is $B$-smooth:}
                              \begin{itemize}[$\circ$]
                                    \item Write $g^{x_i} \pmod p = \prod_{j=1}^{\pi(B)} p_j^{e_ij}$, create the 
                                          vector $e_i = [e_{i1}, e_{i2}, \dots, e_{i\pi(B)}]$ with $e_{ij} \geq 0$, 
                                          and append $e_i$ as the $i$-th row of $M$. 
                                    \item Update $i \gets i+1$. 
                              \end{itemize}
                        \item {\bf if $M$ has reached $T$ rows:} 
                              \begin{itemize}[$\circ$]
                                    \item Exit the relation generation stage. 
                              \end{itemize}
                        \item {\bf else:} 
                              \begin{itemize}[$\circ$]
                                    \item Go back to step $5$. 
                              \end{itemize}
                  \end{itemize}
            \item {\bf Linear algebra stage.} 
                  \begin{itemize}
                        \item Note that $g^{x_i} \pmod p = \prod_{i=1}^{\pi(B)} p_j^{e_{ij}}$ and $p_j = g^{d_j}$ 
                              implies that $x_i \equiv \sum_{j=1}^{\pi(B)} e_{ij} d_j \pmod{p-1}$. 
                        \item Compute $M_{p-1} = M \pmod{p-1}$. 
                        \item Set a column vector of values $x = [x_1, \dots, x_T]^T$, and set a column vector of 
                              variables $d = [d_1, \dots, d_{\pi(B)}]^T$. 
                        \item Use linear algebra to solve the linear system of equations $M_{p-1}d = x$ modulo $p-1$. 
                        \item Determine integers $v_1, \dots, v_{\pi(B)}$ such that $\sum_{i\in I} e_i = 2 \cdot 
                              [v_1, v_2, \dots, v_{\pi(B)}]$. 
                        \item Set $x = \prod_{i\in I} x_i$ and $y = \prod_{j=1}^{\pi(B)} p_j^{v_j}$. 
                  \end{itemize}
            \item {\bf Discrete logarithm finding stage.} 
                  \begin{itemize}
                        \item Select $1 \leq y \leq p-2$ uniformly at random and compute $hg^y \pmod p$. 
                        \item {\bf if $hg^y \pmod p$ is $B$-smooth:} 
                              \begin{itemize}[$\circ$]
                                    \item Write $hg^y \pmod p = \prod_{j=1}^{\pi(B)} p_j^{e_j}$. 
                                    \item Note that $hg^y \pmod p = \prod_{j=1}^{\pi(B)} p_j^{e_j}$ and $p_j = g^{d_j}$ 
                                          implies that $\alpha + y \equiv \sum_{j=1}^{\pi(B)} e_j d_j \pmod{p-1}$. 
                                    \item Output $\alpha = \sum_{j=1}^{\pi(B)} e_j d_j - y \pmod{p-1}$. 
                              \end{itemize}
                        \item {\bf else:}
                              \begin{itemize}[$\circ$]
                                    \item Go back to step $7$. 
                              \end{itemize}
                  \end{itemize}
      \end{enumerate}
\end{algo}

The complexity analysis of the index calculus algorithm is similar to that of 
the random squares factor finding algorithm, which gives us a subexponential 
runtime of $L_p[1/2, 2] = e^{(2+o(1))\sqrt{\ln p \ln\ln p}}$. 